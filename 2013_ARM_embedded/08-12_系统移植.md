- 2013 - 08 - 12（系统移植）
***

# <span style="color:#ff0000;">linux内核移植错误记录：
    ```python
    <1> /tmp/ccUTuv86.s:1833: Error: even register required -- `ldrexd r5,r6,[r3]'
            解决：打开/arch/arm/Kconfig文件
                    修改select GENERIC_ATOMIC64 if (!CPU_32v6K)
                            为select GENERIC_ATOMIC64 if (!CPU_32v6K || !AEABI)
    <2> implicit declaration of function 'need_resched'
            原因：1 没有把函数所在的c文件生成.o目标文件
                            2 没有包含对应头文件
                            3 在函数所在的c文件中定义了，但是没有在与之相关联的.h文件中声明
            解决：在发生错误的文件中包含对应符号的头文件 <linux/sched.h>
    <3> 测试编写的驱动程序出现不应出现的现象时，检查资源释放的顺序，并确保任何资源释放
            后没有再操作
    <4> 编写按键驱动中断函数时，申请中断号失败：
            原因：中断号已被占用或中断处理同名函数已被使用
            解决：查看内核中是否加载了默认的按键处理函数
                            Device Driver--->Input device support--->Keyboard--->XXX gpio keypad support
    <5>开发板上运行的内核应该与驱动编译时使用的内核一致，否则容易出现其他问题
    <6>64位程序与32位程序通信，尤其当使用结构体时，变量的值可能发生变化
 
    logo.bin: nand erase 200000 300000
                    nand write [mem_addr] 200000 300000
 
    配置内核支持ramdisk
    ```
***

# <span style="color:#ff0000;">1). BootLoader
    ```python
    嵌入式Linux软件系统由bootloader、kernel、root filesystem和可选的user filesystem构成：
            bootloader(一次固化) + 内核(多次更新) + 根文件系统(多次更新)[ + user filesystem]
    BootLoader是严重地依赖于硬件而实现的，每种不同的 CPU 体系结构，甚至不同的嵌入式板级
            设备的配置都会有不同的BootLoader。
 
    PC机中：BIOS在完成硬件检测和资源分配后，将硬盘MBR中的BootLaoder读到系统RAM中，
            然后将控制权交给OSBootLoader。
    BootLoader就是在操作系统内核运行之前运行的一段小程序，进行初始化硬件设备、建立内存
            空间的映射图，准备好软件环境，以便最终调用操作系统内核。BootLoader的主要任务就
            是将内核影响从硬盘读到RAM中，然后跳转到内核的入口点去执行，即开始启动操作系统。
 
    BootLoader可以分为以下两种操作模式：
            启动加载模式，将操作系统加载到RAM上，产品发布时工作在这种模式下；
            下载模式，开发人员使用各种命令下载文件，将它们运行在内存中或是烧入Flash设备中。
 
            通常的BootLoader支持这两种工作模式，比如，在启动时处于正常的启动加载模式，并延时几
                    秒，如果此时用户有按键输入，则切换到下载模式，否则继续启动Linux内核。
    ```
## <span style="color:#ff8000;">常用命令(调试或者去操作外围设备)：
    ```python
    u-boot接收的命令都是十六进制的，输入时可省略0x
    支持省写，即当命令前几个字符在所有命令中唯一时，就可使用该省写代替该命令
    u-boot支持的所有命令在include/config_cmd_all.h中
 
    help {命令名}查看特定命令的帮助信息，可使用 ? 来代替help
    下载命令loadb / loads / loadx / loady / tftpboot / nfs
    内存操作命令md(内存查看) / mm(内存修改) / mw(内存填充) / cp(复制命令)
            这些命令都可以带上后缀[ .b, .w, .l ]以表示字节/字/双字(默认)
    NAND Flash命令nand info / nand erase / nand write / nand read
    环境变量命令printenv / setenv / saveenv
            setenv ---> 内存中，saveenv ---> nand中
    启动命令boot / bootm，执行环境变量bootcmd所指定的命令
    ```
    <br />
## <span style="color:#ff8000;">环境变量：给命令提供一些参数，使得命令适应不同的开发环境
    ```python
    <1> bootcmd:下载内核和启动内核，uboot倒计时结束的时候会自动去读取bootcmd中的内容，并且去执行其中的命令
            eg: set bootcmd tftp 20008000 zImage \;bootm 20008000
                            //将名为zImage的内核放入20008000地址，bootm将pc指针指向20008000地
                                    址，其中的zImage在linux中的位置由/etc/inet.conf中指定
                                    ----> bootcmd=tftp 20008000 zImage ;bootm 20008000
                            /***\：转义字符，若使用set bootcmd tftp 20008000 zImage ;bootm 20008000
                            *        则会提示找不到镜像的错误
                            *        ----> bootcmd=tftp 20008000 zImage
                            *        原因是在set之后并没有镜像拷贝，立即执行bootm 20008000则会错误
                            ***/
    <2> bootargs：bootloader传递给内核的信息，说明根文件系统存放的位置
            eg: set bootargs console = ttySAC0,115200 init=/linuxrc root=/dev/nfs 
                            nfsroot=192.168.7.2:/opt/rootfs ip=192.168.7.5
                    //console = {内核的调试信息的输出位置}
                    //init = {linux的第一个用户进程}
                    //root = {根文件系统存放的位置，/dev/nfs(表示在网络远端) / 31:02 / 1f02}
                    //nfsroot = {根文件系统的具体路径，该值由/etc/exports中指定}
                    //ip = {linux系统启动之后，静态分配的ip地址，在bootloader中使用的set ipaddr
                                    是用于bootloader的，在内核启动后便不再可用}
                    //在内核启动后可使用#cat /proc/cmdline 来查看bootargs设置的是否正确
    ```
    <br />
## <span style="color:#ff8000;">U-Boot源码结构：
    ```python
    根目录下的子目录可以分为4类：
            平台相关(cpu) / 架构相关(lib_arm/...) / 开发板相关(board)
            通用的函数(include、lib_generic、common)
            通用的设备驱动程序(disk、driver、dtt、fs、nand_spl、net、post、rtc)
            U-Boot工具、示例程序、文档(doc、example、tools)
 
    u-boot中大部分的宏都在smdkc100.h中定义：
            #include <common.h>
                    #include <config.h>
                            #include <configs/smdkc100.h>
    ```
    <br />
## <span style="color:#ff8000;">Bootloader启动过程：
    ```python
    大多数的Bootloader是两阶段的启动过程，第一阶段使用汇编来实现一些
    依赖于CPU体系结构的初始化，并调用第二阶段的代码，第二阶段则通常使用C语言来实现，
    以实现更复杂的功能，以及更好的可读性和可移植性。
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第一阶段(cpu/arm_cortexa8/start.S)功能：
    ```python
            <1>设置异常向量表
            <2>调用reset，进入SVC32模式(管理模式，ARM态 )
                ---->cpu_init_crit，I/D cache 禁用，MMU禁用(保证访问的地址全部是物理地址)
                    ---->lowlevel_init(board/samsung/smdk2410/lowlevel_init.S)
                            硬件设备初始化，关闭看门狗(看门狗作用，防止代码跑飞)
                            设置SRAM / 关中断(VIC0~3) / 串口初始化(uart_asm_init)
                            设置CPU速度和时钟频率(system_clock_init)
                            内存控制初始化
                                    (mem_ctrl_asm_init(board/samsung/smdkc100/mem_setup.S))
                                    //该部分代码如果有问题，可通过芯片厂商获取技术支持
            <3>设置好栈，以调用c语言代码
            <4>u-boot的完整重定位，确保重定位代码位于前16K，复制整个Bootloader代码到RAM
                    空间nand读操作，通过自己编写的函数nand_ops.c(board/samsung/smdkc100)完成
                            nand初始化，并完成代码的复制，其中的TEXT_BASE由
                            config.mk(board/samsung/smdkc100)中指定
            <5>清bss段(初始值为0、无初始值的全局变量、静态变量放在BSS段)
            <6>跳转到第二阶段代码的C入口点，这之后程序将在内存中运行
                    ldr        pc, _start_armboot        @ jump to C code
                            @ 将调用lib_arm/board.c文件中的start_armboot函数
    ```
    <br />
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;第二阶段功能：
    ```python
        <1>设定一个global_data全局指针，所有文件中都可以引用到这个全局变量
    ```
    ```python
            gd->bd->bi_arch_number = MACH_TYPE_SMDKC100; //1826, 机器id, 需要给内核
            gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100; //0x20000100, 保存传递bootargs
            gd->bd->bi_baudrate = gd->baudrate = 115200
            gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
            gd->bd->bi_dram[0].size = get_ram_size((long *)PHYS_SDRAM_1,HYS_SDRAM_1_SIZE);
 
            gd->env_addr = (ulong)&amp;default_environment[0];
            gd->env_valid = 1; // 设定一个标志
    ```
    <br />
    ```python
        <2>初始化本阶段用到的硬件信息：
    ```
    ```python
            通过调用init_sequence中定义的各个函数来完成
                    其中的板相关函数在board/samsung/smdkc100/smdkc100.c定义
            初始化序列：
                    时钟初始化(获取时钟频率)
                    定时器(timer4)初始化，基本上各个平台都是提供10ms的时间间隔，无需更改
                    环境变量的初始化，对于nand启动，位于common/env_nand.c
                            gd->env_addr = (ulong)&amp;default_environment[0]; //需定义相应的宏
                                    ---->common/env_common.c
                                            ---->默认的环境变量include/configs/smdkc100.h
                            gd->env_valid = 1;
                    串口的初始化(115200，8N1)，serial_init(common/serial.c)，之后就可以使用串口打印输出信息
                    打印u-boot的信息(版本/cpu/DRAM/borad)
                    内存初始化，dram_init
    ```
    <br />
    ```python
        <3>初始化函数分析：
    ```
    ```python
             I). board_init函数中保留了机器类型ID，以及bootargs的存放地址：
                    gd->bd->bi_arch_number = MACH_TYPE_SMDKC100;
                            ---->#define MACH_TYPE_SMDKC100       1826
 
                    gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
                        ---->#define PHYS_SDRAM_1 CONFIG_SYS_SDRAM_BASE /* SDRAM Bank #1
                            ---->#define CONFIG_SYS_SDRAM_BASE 0x20000000 /*DRAM Base
 
             II). dram_init函数(board/samsung/smdkc100/smdkc100.c)检测系统内存映射
                    (momery map)，确定板上使用了多少内存，以及它们的地址空间，不需要考虑可
                    以适应各类情况的复杂算法：
                    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;        //指定开发板的内存起始地址
                    ---->#define PHYS_SDRAM_1 CONFIG_SYS_SDRAM_BASE /* SDRAM Bank #1 */
                            ---->#define CONFIG_SYS_SDRAM_BASE        0x20000000
                                            //文件include/configs中定义
 
                    gd->bd->bi_dram[0].size = get_ram_size((long *)PHYS_SDRAM_1,
                                            PHYS_SDRAM_1_SIZE);        //指定开发板内存大小
                    ---->#define PHYS_SDRAM_1_SIZE        (256 << 20) /*0x8000000, 256 MB Bank #1*/
                                            //文件include/configs中定义
    ```
    <br />
    ```python
        <4>其他的一些初始化：
    ```
    ```python
            堆的初始化mem_malloc_init (_armboot_start - CONFIG_SYS_MALLOC_LEN,
                            CONFIG_SYS_MALLOC_LEN);
            nand初始化nand_init();        //基于mtd架构，位置drivers/mtd/nand/nand.c
                    nand_info_t nand_info[CONFIG_SYS_MAX_NAND_DEVICE];
                            //CONFIG_SYS_MAX_NAND_DEVICE用于定义nand数量
                    void nand_init(void)
                            ---->nand_init_chip(struct mtd_info *mtd, struct nand_chip *nand,
                                     ulong base_addr) {
                                    nand->IO_ADDR_R = nand->IO_ADDR_W = (void
                                                    __iomem *)base_addr;
                                            board_nand_init(nand);
                                            nand_scan(mtd, maxchips);
                                    }
 
            环境变量的重定位env_relocate ();
                    ---->env_ptr = (env_t *)malloc (CONFIG_ENV_SIZE);
                            env_relocate_spec ();
                            ...
                            gd->env_addr = (ulong)&amp;(env_ptr->data);
            获取ipaddr的值gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
            网卡的初始化eth_initialize(gd->bd);
                       eth_init(gd->bd);
    ```
    <br />
    ```python
        <5>死循环mainloop，倒计时(等待计时结束 / 中止)
    ```
    ```python
        <6>将内核映像和根文件系统映像从Flash上读到RAM空间中
    ```
    ```python
        <7>为内核设置启动参数(bootdelay / bootcmd 等)
    ```
    ```python
        <8>调用内核，通过调用lib_arm/bootm.c中的do_bootm_linux函数完成调用
    ```
    ```python
            int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
            {
                    /* 设置标记列表 */
                    ...
                    int        machid = bd->bi_arch_number;
                    ...
                    /* 调用内核 */
                    theKernel (0, machid, bd->bi_boot_params);
                            //其中machid为机器类型ID，bd->bi_boot_params为标记列表开始地址
 
            在调用内核之前，以下条件要满足：
             I). CPU寄存器的设置：
                    R0 = 0
                    R1 = 机器类型ID，(对于smdkc100为1826(0x722))
                            参见linux/arch/arm/tools/mach-types
                    R2 = 启动参数标记列表在RAM中起始基地址
                            eg: theKernel(0, ARCH_NUMBER, (u32)kernel_params_start);
             II). CPU工作模式：
                    必须禁止中断(IRQ和FIQ)
                    CPU必须为SVC模式
            III). Cache和MMU设置：
                    MMU必须关闭
                    指令Cache可以打开也可以关闭
                    数据Cache必须关闭
    ```
    <br />
## <span style="color:#ff8000;">Bootloader与内核的交互：
    ```python
    Bootloader与内核的交互是单向的，传递方法只有一个：Bootloader将参数放在某个约定的地址之后再启动内核，内核启动
            以后从这个地方获得参数，Linux2.4以后的内核都期望以标记列表的形式来传递参数。
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;标记列表：
    ```python
            标记列表以标记ATAG_CORE开始，以ATAG_NONE结束，标记的数据结构是tag，由一个
                    tag_header结构与一个联合体构成，其中的tag_header用以表示标记的类型与长度，
                    对于不同类型的标记使用联合体中不同的结构体
                    struct tag {
                            struct tag_header hdr;
                            union {
                                    struct tag_core        core;
                                    struct tag_mem32        mem;
                                    struct tag_cmdline        cmdline;
                                    ...
                            };
                    struct tag_header {
                            __u32 size;
                            __u32 tag;
                    };
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;标记列表示例(取自lib_arm/bootm.c文件，定义对应的宏即可)：
    ```python
            /** 设置ATAG_CORE标记，假设参数存放地址位于0x3000_0100 **/
            static void setup_start_tag (bd_t *bd)
            {
                    params = (struct tag *)0x3000100;
                    params->hdr.tag = ATAG_CORE;
                    params->har.size = tag_size(tag_core);
 
                    params->u.core.flags = 0;
                    params->u.core.pagesize = 0;
                    params->u.core.rootdev = 0;
 
                    params = tag_next(params);        //params指向当前标记的末尾
            }
 
            /** 设置命令行标记，# defined CONFIG_CMDLINE_TAG 1 **/
            static void setup_commandline_tag (bd_t *bd, char *commandline)
            {
                    ...
                    char *p = "root=/dev/nfs init=/linuxrc console=ttySAC0";
                    params->hdr.tag = ATAG_CMDLINE;
                    params->hdr.size = (sizeof(struct tag_header) + strlen(p) + 1 + 4) >> 2;（？）
                    strcpy(params->u.cmdline.cmdline, p);
                    params = tag_next(params);
            }
 
            使用setup_memory_tags(# defined CONFIG_SETUP_MEMORY_TAGS 1 )设定内存标记，
                    setup_end_tag设定结束标记
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;3&gt;u-boot命令的格式：
    ```python
            在源代码中查找对应命令的实现函数格式如：do_go / do_saveenv / do_bootm
            struct cmd_tbl_s {
                    char                *name;        /* Command Name                        */
                    int                maxargs;        /* maximum number of arguments                */
                    int                repeatable;        /* autorepeat allowed?                        */
                                            /* Implementation function                */
                    int                (*cmd)(struct cmd_tbl_s *, int, int, char *[]);
                    char                *usage;        /* Usage message        (short)                */
                    char                *help;        /* Help message        (long)                */
                    ...
            };
 
            #define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \
                            cmd_tbl_t __u_boot_cmd_##name Struct_Section = \
                                    {#name, maxargs, rep, cmd, usage, help}
                    //参数：name命令名(非字符串) / maxargs最大参数个数 /repeatable命令是否可重复
                    //        command对应的处理函数指针，格式
                                    (*cmd)(struct cmd_tbl_s *, int,int, char *[]);
                    //        usage / help使用说明
                    //其中的##表示连接字符串，#代表参数取为字符串
                    eg: U_BOOT_CMD(
                                    tftpboot,        3,        1,        do_tftpb,
                                    "boot image via network using TFTP protocol",
                                    "[loadAddress] [[hostIPaddr:]bootfilename]"
                            );
 
            对于每个使用U_BOOT_CMD宏来定义的命令，都会在".u_boot_cmd"段中定义一个
                    cmd_tbl_t结构：
                    #define Struct_Section __attribute__ ((unused,section (".u_boot_cmd")))
    ```
    <br />
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;4&gt;u-boot中命令的解析：
    ```python
            start_armboot();
            ---->mian_loop();
                ---->run_command("tftp", 0); //tftp 20008000 zImage ==> argv[0] argv[1] argv[2]
                    ---->cmd_tbl_t *cmdtp;
                    cmdtp = find_cmd("tftp")
                     ---->int len = &amp;__u_boot_cmd_end - &amp;__u_boot_cmd_start;
                         return find_cmd_tbl("tftp", &amp;__u_boot_cmd_start, len);
                        ---->cmd_tbl_t *cmdtp_temp = table;
                            for (cmdtp = table; cmdtp != table + table_len; cmdtp++)
                            f (strncmp ("tftp", cmdtp->name, len)
                                return cmdtp;
                    (cmdtp->cmd) (cmdtp, flag, argc, argv);
    ```
## <span style="color:#ff8000;">U-Boot源码编译：
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;过程：
    ```python
             I). 设置交叉工具链：CROSS_COMPILE =arm-unknown-linux-gnueabi-
             II). 配置：make smdkc100_config
            III). 编译：make -j2  //-j2指定使用2个线程来同时进行编译，一般与CPU核数量对应
                    编译完成后生成u-boot(ELF格式)、u-boot.bin(二进制)、u-boot.srec(S-Record格式)
                    在编译成功后还会在tools子目录下生成一些工具，如mkimage等，可将它们复制到
                            /usr/local/bin目录下，如生成内核时，会使用mkimage来生成uImage
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;Makfile分析(make smdkc100_config)：
    ```python
            SRCTREE                := $(CURDIR)
            ...
            unconfig:
                      @rm -f $(obj)include/config.h $(obj)include/config.mk \
                    $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \
                    $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep
            ...
            MKCONFIG    := $(SRCTREE)/mkconfig                 ## shell脚本
            ...
            smdkc100_config:    unconfig
                    @$(MKCONFIG) $(@:_config=) arm arm_cortexa8 smdkc100 samsung s5pc1xx
                    ## <--->./mkconfig smdkc100 arm arm_cortexa8 smdkc100 samsung s5pc1xx
                                    ## 控制源码的编译，$(@:_config=)的结果是将目标中的 _config 去掉
            ...
            include $(TOPDIR)/config.mk
            ...OBJS = cpu/$(CPU)/start.o
                    ## start.o(cpu/arm_cortexa8/start.o)必须是第一个值
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;3&gt;对于./mkconfig smdkc100 arm arm_cortexa8 smdkc100 samsung s5pc1xx的详细说明:
    ```python
            ## 参数：       目标   架构 CPU         板相关    [制造商]  [SOC](mkconfig第六行)
 
            第一个参数:smdkc100
                    用于确定include/configs/smdkc100.h
            第二个参数:arm
                    用于确定架构的, lib_arm, include/asm-arm
            第三个参数: arm_cortexa8
                    用于确定arm core的类型,并且链接cpu/arm_cortexa8目录
                            cpu/arm_cortexa8/s5pc1xx
            第四个参数:smdkc100
            第五个参数:samsung
                    用于确定开发板文件路径,并且链接board/samsung/smdkc100目录
            第六个参数:s5pc1xx
                    用于确定SOC,同时使用include/asm-arm/arch-s5pc1xx
                    cpu/arm_cortexa8/s5pc1xx
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;4&gt;u-boot配置文件(include/configs/&lt;board_name&gt;.h)：
    ```python
            配置文件主要有以下几类宏：
                    "CONFIG_"类，用于选择CPU/SOC/开发板类型，以及设置系统时钟/选择设备驱动等
                    "CONFIG_SYS_"类，用于设置malloc大小等更细节的参数
                    "CONFIG_CMD_"类，本开发板支持的命令，u-boot支持的所有命令在
                            include/config_cmd_all.h
    ```
### <span style="color:#00ff00;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;5&gt;config.mk文件：
    ```python
            LDFLAGS += -Bstatic -T $(obj)u-boot.lds $(PLATFORM_LDFLAGS)
            ifneq ($(TEXT_BASE),)
            LDFLAGS += -Ttext $(TEXT_BASE)
            endif
 
            其中的u-boot.lds(规定目标文件的布局)位于cpu/arm_cortexa8/u-boot.lds
                    .text段的格式：
                            .text        :
                            {
                                    cpu/arm_cortexa8/start.o        (.text)
                                    board/samsung/smdkc100/lowlevel_init.o        (.text)
                                    board/samsung/smdkc100/mem_setup.o        (.text)
                                    board/samsung/smdkc100/nand_ops.o        (.text)
                                    *(.text)
                            }
 
            TEXT_BASE值由board/samsung/smdkc100/config.mk中定义
                    TEXT_BASE = 0x34800000 //可根据实际更改
            TEXT_BASE作用:         指定uboot的链接起始位置
                            指定重定位代码的起始位置
    ```
    <br />
## <span style="color:#ff8000;">u-boot mtd(内存技术设备)架构：
    ```python
    应用接口层
    mtd设备层
    nand芯片层
    ```
***

# <span style="color:#ff0000;">2). Linux内核移植
    ```python
    /arch/arm/kernel/head.S是内核执行的第一个文件，在U-Boot调用内核时，r1寄存器中存储机器
            类型ID，内核会用到它
    内核传递启动参数：
            make menuconfig-->Boot options-->Default kernel commad string / Always use the default...
    使用补丁文件配置：
            <1> 从arch/arm/configs中找到相应的内核默认配置文件(s5pv210_defconfig)，在linux内核根
                    目录下执行 make s5pv210_defconfig，该命令将默认配置文件复制为根目录下的.config
            <2> 修改Makefile：ARCH ?= arm         CROSS_COMPLE ?= arm-linux-
            <3> 使用patch命令生成移植后的linux内核
                    $ cd <linux kernel path>
                    $ cp ../linux_2_6_35_7_dm9000_nand_noconfig_nomakefile.diff ./
                    $ patch -p2 < linux_2_6_35_7_dm9000_nand_noconfig_nomakefile.diff
            <4> 使用配置好的配置文件：
                    $ cp   ../xxx_defconfig    .config
    ```
## <span style="color:#ff8000;">Makefile分析(详细分析位于Documents/kbuild/makefiles.txt文件中)：
    ```python
    Makefile分类：
            顶层Makefile：从总体上控制内核的编译、连接，直接包含arch/$(ARCH)/Makefile
                    include $(srctree)/arch/$(SRCARCH)/Makefile
            .config：内核配置文档，所有Makefile会读取该文件以决定使用哪些文件
            arch/$(ARCH)/Makefile：对应体系结构的Makefile，决定哪些体系结构相关的文件参与内
                            核的生成，并提供一些规则来生成特定格式的内核映像
            scripts/Makefile.*：Makefile共用的通用规则、脚本等，包含所有用来根据kbuild
                             Makefile构建内核所需的定义和规则
            kbuild Makefiles：各级目录下的Makefile，被上一层的Makefile调用来编译当前目录下的
                            文件，决定所在目录下哪些文件将被编译
 
    编译过程：
            顶层Makefile将13个子目录分为5类，init-y / drivers-y / net-y / libs-y / core-y，
                    在arch/$(ARCH)/Makefile还有另一类head-y
            编译内核时依次进入以上列出的各个子目录，并执行其中的Makefile，每个子目录都会生
                    成一个build-in.o(libs-y目录下可能是lib.a)，最终一起被链接成内核映像vmlinux
            Makefile中使用obj-y( += foo.o)来定义哪些文件被编译进内核
                                    使用obj-m来定义哪些文件被编译成模块
                                    使用lib-y来定义哪些文件被编译成库文件
                                    obj-y / obj-m还可以用来指定要进入的下一层子目录
    ```
    <br />
## <span style="color:#ff8000;">Kconfig分析(Documents/kbuild/kconfig-language.txt)
    ```python
    config条目，用来生成菜单、进行多项选择等
    menu条目，用于生成菜单
    choice条目，用于将多个配置选项组合在一起
    comment条目，定义一些帮助信息，出现在界面的第一行
    source条目，用于读入另一个Kconfig文件
 
    eg: menu "System Type"
            config MMU
                    bool "MMU-based Paged Memory Management Support"
                    default y
                    help
                            ...
            choice
                        prompt "ARM system type"        //标题
                default ARCH_VERSATILE
            config ARCH_AAEC2000
                    ...
            config ARCH_S5PC100
                    ...
            endchioce
            ...
            endmenu
    ```
    <br />
## <span style="color:#ff8000;">zImage与uImage：
    ```python
    zImage是通过压缩内核文件vmlinux后，再加上一段解压启动代码得到。而
    uImage是u-boot使用bootm命令引导的Linux压缩内核映像文件格式，通过使用mkimage(编
    译好的uboot源码下的tools/mkimage)工具对普通的压缩内核映像文件zImage加工得到。它
    是在zImage之前加上一个长度为 64字节的“头”，说明这个内核的版本、加载位置、生成时间、
    大小等信息；其0x40之后与zImage没区别。有了uImage头部的描述，u-boot就知道对应
    Image的信息，如果没有头部则需要自己手动设置那些参数。
 
    生成uImage文件：将编译好的uboot源码下的/tools/mkimage拷贝到系统/usr/sbin目录下，
            并在编译内核时使用make uImage
    ```
    <br />
***

# <span style="color:#ff0000;">3). Linux文件系统制作
    ```python
    虚拟的文件系统类型：如proc、sysfs，它们的文件并不存储在实际的设备上，而是在访问它们时
            由内核临时生成。
    ```
## <span style="color:#ff8000;">Linux根文件系统目录结构：
    ```python
    /bin目录，存放所有用户都可以使用的基本命令
    /sbin目录，用于存放只有管理员能够使用的基本命令，系统命令还可以存放在/usr/sbin(一般
                    的系统命令)、/usr/local/sbin目录下(本地安装的系统命令)
    /dev目录，设备文件，如/dev/ttySAC0表示串口0，/dev/mtdblock1表示MTD设备的第二个分
                    区
    /etc目录，配置文件，如exprot文件用来配置NFS文件系统
                    fstab文件用来挂接文件系统，当执行 mount -a时会解析这个文件
                    mtab用来显示已经挂载的文件系统(通常会是/proc/mounts的链接文件)
                    inittab用来配置init进程，以创建其他子进程
                    init.d/rcS 是一个脚本文件，用来添加系统启动后自动执行的命令
    /lib目录，存放共享库和可加载模块
    /home目录，用户目录
    /root目录，根用户目录
    /usr目录，存放的是共享、只读的程序和数据，可存在另一个分区中，系统启动后再挂载
    /var目录，存放可变的数据
    /proc目录，作为proc文件系统的挂载点
                    常在/etc/fstab中配置如： # mount -t proc none /proc
    /mnt目录：用于临时挂载某个文件系统
    /tmp目录：临时文件，必须存在并可以访问
    ```
## <span style="color:#ff8000;">移植Busybox：
  - Busybox用来创建/bin、/sbin等目录下的可执行文件
### <span style="color:#00ff00;">init进程：
    ```python
    init进程的执行进程通常是/sbin/init，也可以通过命令行参数 init = xxxxx 指定某个程序作为init进程运行，
    在嵌入式系统中通常使用Busybox集成的init进程
    内核启动的最后一步就是启动init进程，代码位于init/main.c
            static noinline int init_post(void)
                    __releases(kernel_lock) {
                    ...
                    /* 如果execute_command指定了要运行的程序，启动它，通过 init=xxx 指定 */
                    if (execute_command) {
                            run_init_process(execute_command);
                            ...
                    }
                    ...
                    ----> static void run_init_process(char *init_filename) {
                            /* 用来创建一个用户进程，在执行成功时，将不会返回 */
                            kernel_execve(init_filename, argv_init, envp_init);
                    }
            }
    ```
### <span style="color:#00ff00;">etc/inittab文件
    ```python
    Busybox init进程对应的代码位于init/init.c文件中，如果存在etc/inittab文件，则按照它的指示创建各种子进程
    inittab文件的相关文档在example/initab文件中
    在etc/inittab文件的控制下，init进程的行为如下：
            在系统启动前期，init进程首先启动<action>为sysinit / wait / once的3类子进程
            在系统正常运行期间，init进程首先启动<action>为respawn / askfirst的2类子进程，
                    并监视它们，在发现某个子进程退出时重新启动它们
            在系统退出时，执行<action>为shutdown / restart / ctrlaltdel 的3类子进程
    ```
    <br />
### <span style="color:#00ff00;">编译/安装Busybox
    ```python
    make menuconfig
    修改Makefile中的ARCH / CROSS_COMPILE
    make 
    make install 
            //busybox默认安装路径为源码目录下的_install ，可使用
                    make CONFIG_PREFIX=dir_path install 以指定安装路径
    完成后将生成/bin、/sbin、linuxrc、/usr，其中的所有命令都是/bin/busybox的符号链接
    ```
    <br />
### <span style="color:#00ff00;">BusyBox的常用配置：
    ```python
    Tab键自动补齐：Busybox Setting--->Busybox Library Tuning--->Tab completion
    编译为静态链接(在没有其他库支持时也能启动)：
            Busybox Setting--->Build Options--->Build Busybox as a static binary
    指定编译工具路径：BS--->Build Option--->Cross Compiler prefix
    init进程读取的配置文件(/etc/inittab)：Init Utilities--->Support reading an inittab file
    ```
## <span style="color:#ff8000;">使用动态glibc链接库：
    ```python
    使用交叉编译工具链中的lib库
            $ cp /usr/local/arm/4.2.2-eabi/lib/*  lib/ -raf 
    删除库文件中的符号表，也叫瘦身 
            $ find ./lib -name '*.a' | xargs rm -rf 
            $ arm-unknown-linux-gnueabi-strip lib/*
 
    一个基本库的复制命令：
            $ cd {PATH1}/arm-concenwit-linux-gnueabi/concenwit/usr/lib
            $ sudo cp -a ld-2.10.1.so ld-linux.so.3 libc.so libc-2.10.1.so libc.so.6 libm.so libm-2.10.1.so libm.so.6
                     {PATH2}/busybox-1.19.4/_install/lib
    ```
    <br />
## <span style="color:#ff8000;">构建etc目录：
    ```python
    创建etc/inittab文件(参照examle/inittab文件)，init进程根据etc/inittab文件来创建其他子进程
    创建etc/init.d/rcS文件：脚本文件，可以在里面添加想自动执行的命令，需添加可执行权限
            #!/bin/sh
            echo ">>>>>in /etc/init.d/rcS<<<<<<<<<<<<<<<<<"
            /bin/mount -a
            echo /sbin/mdev > /proc/sys/kernel/hotplug
            /sbin/mdev -s
    创建etc/fatab文件，表示执行 mount -a 命令后将挂载的文件系统
            #device        mount-point        type                options        dump        fsck order 
            proc        /proc                proc                defaults        0        0 
            tmpfs        /tmp                tmpfs                defaults        0        0 
            sysfs        /sys                sysfs                defaults        0        0 
            tmpfs        /dev                tmpfs                defaults        0        0 
    ```
    <br />
## <span style="color:#ff8000;">构建dev目录：
    ```python
    静态创建：$ sudo mknod  dev/console c 5 1 
            $ sudo mknod  dev/null c 1 3
    使用mdev创建设备文件(参见busybox/docs/mdev.txt)：
            mdev的用途有两个：初始化/dev、动态更新
            需要内核支持sysfs文件系统，并挂载到/sys，为减少对flash的读写，还要支持tmpfs文件系统，
                    这些可以在etc/fatab文件中添加
            修改etc/init.d/rcS文件以实现自动启动
                    mkdir /dev/pts        ## devpts用来支持外部网络连接(telnet)的虚拟终端
                    mount -t devpts devpts /dev/pts
                    echo /sbin/mdev > /proc/sys/kernel/hotplug        ## 设置内核，设备插拔时调用mdev
                    mdev -s        ## 在/dev目录下生成内核支持的所有设备节点
    ```
    <br />
## <span style="color:#ff8000;">构建其他目录：proc / mnt / tmp / sys / root
***

# <span style="color:#ff0000;">4). Linux文件系统扩展
## <span style="color:#ff8000;">嵌入式相关的文件系统：
    ```python
    cramfs：压缩的只读文件系统(只读文件系统启动速度快于可读写的文件系统)
            特点：启动块，文件最大支持256MB，单个文件最大16MB
    squashfs：压缩的只读文件系统
            特点：压缩比最大，启动速度慢于cramfs，多用与路由器、ubuntu的发行光盘
    jffs2：日志式闪存文件系统，可读写
            特点：可读写，挂载慢，主要用于Nor Flash，基于MTD驱动层，缺点是当数据占到文件
                    系统的75~80%时，性能会急剧下降
    yaffs：专用于Nand Flash，是在GPL协议下发布的，速度快、占用内存小、不支持压缩，文
            件以固定大小块进行存储
    ubifs：可读写文件系统
            特点：支持NandFlash，挂载快，它的实现和其他文件系统不一样，引进了一个“卷”的概念
    ```
## <span style="color:#ff8000;">添加开机启动程序：
    ```python
    编译一个可执行程序：/bin/hello_arm
    /etc/init.d/rcS中启动可执行程序
            方法一： 直接在/etc/init.d/rcS添加一条：/bin/hello_arm 
            方法二：另外写一个脚本，然后在/etc/init.d/rcS中启动这个脚本 
                    写一个脚本:$ vi /etc/local/mysrv.sh
                            #!/bin/ash
                            echo "my first app"
                            /bin/hello_arm 
                    然后在/etc/init.d/rcS添加一条：/etc/local/mysrv.sh
    ```
## <span style="color:#ff8000;">设定从内存卡启动文件系统：
    ```python
    setenv bootargs root=nfs nfsroot=192.168.1.8:/opt/filesystem 
            ip=192.168.1.6:192.168.1.8::::eth0:on init=/linuxrc console=ttySAC0,115200
    bootargs=noinitrd root=/dev/mtdblock3 rootfstype=yaffs2 init=/init console=ttySAC0
    bootargs=root=/dev/mtdblock3 init=/linuxrc console=ttySAC0,115200 rootfstype=cramfs
    ```
## <span style="color:#ff8000;">制作cramfs文件系统(rootfs)：
    ```python
    cramfs文件系统是只读的，系统提供制作cramfs文件系统的工具，可以直接使用。具体操作如下：
     I). $ cd /opt
            $ mkfs.cramfs rootfs rootfs.cramfs 
     II). 将rootfs.cramfs拷贝到/tftpboot目录下 
            $ sudo cp rootfs.cramfs /tftpboot 
    III). 将rootfs.cramfs烧写到nand flash的第三个分区上 
            u-boot下执行如下命令：
                    # tftp 20008000 rootfs.cramfs 
                    # nand erase 400000 400000
                    # nand write 20008000 400000 400000 
    IV). 重新设置u-boot启动参数 
            # setenv bootcmd tftp 20800000 zImage \;  go 20800000 
            # setenv bootargs root=/dev/mtdblock2 rootfstype=cramfs init=/linuxrc console=ttySAC0,115200 
            # saveenv
     V). 启动开发板，测试是否成功
    ```
## <span style="color:#ff8000;">制作jffs2文件系统(usrfs)：
    ```python
     I). 配置内核支持jffs2文件系统 
            File systems ---> 
                    [*] Miscellaneous filesystems ---> 
                <*>  Journalling Flash File System v2 (JFFS2) support 
            重新编译内核并拷贝到/tftpboot下 
     II). zlib的编译 
            解压zlib-1.2.3.tar.bz2并进入zlib-1.2.3配置编译安装 
                $ tar xvf zlib-1.2.3.tar.bz2 
                $ cd zlib-1.2.3 
            $ ./configure 
            $ make 
            $ sudo make install 
    III). mtd工具编译 
            解压mtd-snapshot-20050519.tar.bz2 并进入mtd/util编译安装 
            $ tar xvf mtd-snapshot-20050519.tar.bz2 
            $ cd mtd/util 
            $ make 
            $ sudo make install 
            这样我们的系统里就有了mkfs.jffs2这个工具了 
    IV). jffs2文件系统镜像制作 
            $ cd /opt 
            $ mkfs.jffs2  -r rootfs -o rootfs.jffs2 -e 0x20000 --pad=0x400000 -n 
                    /***-e: nand的块大小: 128K
                        --pad= : myrootfs.jffs2指定为多大: 和分区大小一致  (该选项不是一定要的) 
                        -n : 不要打印不必要的调试信息
                    ***/
            $ sudo cp rootfs.jffs2 /tftpboot 
     V). jffs2文件系统烧写 
            # tftp 20008000 rootfs.jffs2 
            # nand erase 400000 400000 
            # nand write 20008000 400000 400000 
    VI). 设置u-boot启动参数 
            # setenv bootcmd tftp 20008000 zImage\; go 20008000 
            # setenv bootargs root=/dev/mtdblock2  rootfstype=jffs2 rw init=/linuxrc console=ttySAC0,115200 
            # saveenv 
    VII). 重新启动开发板，查看是否成功 
    ```
## <span style="color:#ff8000;">在cramfs文件系统的rootfs下的home目录下挂载jffs2文件系统：
    ```python
    Creating 4 MTD partitions on "NAND 256MiB 3,3V 8-bit":
    0x000000000000-0x000000100000 : "bootloader"
    0x000000100000-0x000000400000 : "kernel"
    0x000000400000-0x000000800000 : "rootfs"
    0x000000800000-0x000010000000 : "usrfs"
 
    farsight@ubuntu:/opt/myrootfs$ vim etc/init.d/rcS
            echo "ready to mount /dev/mtdblock3 to /home"
            mount -t jffs2 /dev/mtdblock3 /home
 
    sudo mkfs.cramfs myrootfs myrootfs.cramfs
 
    mkdir usrdata
    ./mkfs.jffs2 -r usrdata/ -o usrdata.jffs2 -e 0x20000 --pad=0x2000000 -n
 
    =====>
    tftp 20008000 myrootfs.cramfs
    nand erase 0x400000 0x400000
    nand write 0x20008000 0x400000 0x400000
    set bootargs console=ttySAC0,115200 init=/linuxrc root=/dev/mtdblock2 rootfstype=cramfs
 
    tftp 20008000 usrdata.jffs2
    nand erase 0x800000 0x2000000
    nand write.jffs2 0x20008000 0x800000 0x2000000
 
    ===============>
    tftp 20008000 usrdata.jffs2
    nand erase 0x800000 0xf800000
    nand write.jffs2 0x20008000 0x800000 0xf800000
    ```
  - <br />
