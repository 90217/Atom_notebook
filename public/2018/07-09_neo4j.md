# ___2018 - 07 - 09 Neo4j___
***

# 目录
***

# Neo4j
## 安装
  - [neo4j github](https://github.com/neo4j/neo4j)
  - [Neo4j Graphs for Everyone](https://neo4j.com)
  - [Neo4j Desktop Debian Installation](https://neo4j.com/docs/operations-manual/current/installation/linux/debian/)
  - [Neo4j Debian Packages](https://debian.neo4j.org)
  - [Other Neo4j Releases](https://debian.neo4j.org)
  - [O’Reilly’s Graph Databases](https://neo4j.com/graph-databases-book/?ref=home)
  - **安装 Neo4j**
    ```shell
    ''' Neo4j 要求 JAVA 1.8 '''
    apt install maven openjdk-8-jdk
    apt install debhelper devscripts dos2unix dpkg make xmlstarlet
    export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64

    ''' 方法1，Github 中的安装方法，启动一个安装程序，需要更多配置 '''
    # You will need a license for install4j, which is only needed for Neo4j Desktop
    curl -O http://download-keycdn.ej-technologies.com/install4j/install4j_linux_6_1_4.deb
    dpkg -i install4j_linux_6_1_4.deb

    ''' 方法2，debian source list，E: The repository 'https://debian.neo4j.org/repo stable/ Release' does not have a Release file. '''
    wget -O - https://debian.neo4j.org/neotechnology.gpg.key | sudo apt-key add -
    echo 'deb https://debian.neo4j.org/repo stable/' | sudo tee -a /etc/apt/sources.list.d/neo4j.list
    sudo apt-get update

    ''' 方法3，tar 文件 '''
    # https://neo4j.com/download/other-releases/#releases
    wget https://go.neo4j.com/download-thanks.html?edition=community&release=3.4.1&flavour=unix
    tar xvf neo4j-community-3.4.1-unix.tar.gz
    cd neo4j-community-3.4.1
    cd bin
    ./neo4j console
    # INFO  Remote interface available at http://localhost:7474/

    # Add bin to envirenment PATH
    ```
  - **启动**
    ```shell
    neo4j start
    # Browse at http://localhost:7474/
    Default username / password: neo4j / neo4j
    ```
  - **Hello world**
    ```python
    CREATE (matrix:Movie { title:"The Matrix", released:1997 })
    CREATE (cloudAtlas:Movie { title:"Cloud Atlas", released:2012 })
    CREATE (forrestGump:Movie { title:"Forrest Gump", released:1994 })
    CREATE (keanu:Person { name:"Keanu Reeves", born:1964 })
    CREATE (robert:Person { name:"Robert Zemeckis", born:1951 })
    CREATE (tom:Person { name:"Tom Hanks", born:1956 })
    CREATE (tom)-[:ACTED_IN { roles: ["Forrest"]}]->(forrestGump)
    CREATE (tom)-[:ACTED_IN { roles: ['Zachry']}]->(cloudAtlas)
    CREATE (robert)-[:DIRECTED]->(forrestGump)
    RETURN matrix,cloudAtlas,forrestGump,keanu,robert,tom
    ```
    ![](images/neo4j_hello_world.png)
## Basic concept
  - **Graph 图** 是表示对象与对象之间关系的方法
    - **对象** 又称 节点 Node / 顶点 Vertex / 实体 Entity，描述具体的一件事物
    - **关系** 又称 边 edge，描述对象之间的关系
    - **G=(V, E)** 表示一张图，V 表示节点的集合，E 表示边集合

    ![](images/neo4j_node_example.png)     
  - **图的学习任务分类**
    - 社交网络 / 搜索排名 / 评分系统 / 推荐系统 / 知识图谱 / 风险控制
    - 节点上的任务：利用图中节点的关系可以做包括分类（比如风险识别、价值排名等任务）、聚类（社群检测、用户画像等任务）
    - 边上的任务：通过图中节点之间是否有边可以做比如推荐、知识推理等任务
    - 图上的任务：图可以做像高分子分类、3D视觉分类等任务
  - **Graph 图** 基本组成
    - **Nodes 节点** 数据的名称
      ```js
      (a) //actors
      (m) //movies
      ( ) //some anonymous nod
      ```
    - **Relationships 关系** 节点之间的连接
      ```js
      -[r]-> //a relationship referred to as "r"
      (a)-[r]->(m) //actors having a relationship referred to as "r" to movies
      -[:ACTED_IN]-> //the relationship type is ACTED_IN
      (a)-[:ACTED_IN]->(m) //actors that ACTED_IN some movie
      (d)-[:DIRECTED]->(m) //directors that DIRECTED some movie
      ```
      - 关系有特定的方向与类型
      - 关系可以包含属性
    - **Properties 属性** 键值队的形式存储数据值
      ```js
      (m {title:"The Matrix"}) //Movie with a title property
      (a {name:"Keanu Reeves",born:1964}) //Actor with name and born property
      (a)-[:ACTED_IN {roles:["Neo"]}]->(m) //Relationship ACTED_IN with roles property
      ```
    - **Label 标签** 节点可以通过标签组合在一起
      ```js
      (a:Person) //a Person
      (a:Person {name:"Keanu Reeves"}) //a Person with properties
      (a:Person)-[:ACTED_IN]->(m:Movie) //a Person that ACTED_IN some movie
      ```
      - 一个节点可以有 0 个或多个标签
      - 标签没有属性
  - **Editor**
    - **:help** 查看命令的帮助信息
    - **:clear** 清空
    - **:play** 运行
      ```js
      // Guides
      :play intro
      :play concepts
      :play cypher

      // Examples
      :play movie graph
      :play northwind graph
      ```
    - **<shift-enter>** Switch to multi-line editing
    - **<ctrl-enter>** 运行
## Cypher Basic
  - **Cypher** Neo4j 图查询 / 创建语言，描述 **找什么**，而不是 **怎么找**
  - **CREATE** 创建节点
    ```js
    // 语法规则
    CREATE (节点名: 标签 {节点属性})
    ```
    ```js
    CREATE (ee:Person { name: "Emil", from: "Sweden", klout: 99 })
    ```
  - **DELETE** 删除当前所有节点 / 关系
    ```js
    MATCH(n:Person) DETACH
    DELETE n
    ```
  - **MATCH** 查找节点或关系
    ```js
    // 语法规则
    MATCH (匹配出的变量名 : 匹配的标签) WHERE 过滤结果 RETURN 返回特定结果
    ```
    ```js
    MATCH (pp:Person) WHERE pp.name = "Emil" RETURN pp;
    ```
    CREATE 后面直接用 MATCH 时，需要 WITH
    ```js
    create (ee:Person {name: "Emil", from: "Sweden", klout: 99})
    with ee
    match (pp:Person) where pp.name="Emil" return pp
    ```
    ![](images/neo4j_match.png)
  - **CREATE relationships** 创建关系
    ```js
    // 语法规则
    CREATE (节点名 1)-[:关系名 {关系属性}]->(节点名 2)
    ```
    ```js
    create (ee:Person {name: "Emil", from: "Sweden", klout: 99})
    create (et:Person {name: "et"})
    create (et)-[:KNOWS {by: "swimming"}]->(ee)
    return ee, et
    ```
    ![](images/neo4j_relation.png)
  - 创建多个节点以及关系
    ```js
    create (ee:Person {name: "Emil", from: "Sweden", klout: 99})
    WITH ee
    MATCH (pp:Person) WHERE pp.name="Emil"
    CREATE (js:Person {name: "Johan", from: "Sweden", learn: "surfing"}),
           (ir: Person {name: "Ian", from: "Belgium", title: "author"}),
           (rvb: Person {name: "Rik", from: "England", pet: "Orval"}),
           (ally: Person {name: "Allison", from: "California", hobby: "surfing"}),
           (ee)-[:KNOWS {since: 2001}]->(js), (ee)-[:KNOWS {rating: 5}]->(ir),
           (js)-[:KNOWS]->(ir), (js)-[:KNOWS]->(rvb),
           (ir)-[:KNOWS]->(js), (ir)-[:KNOWS]->(ally),
           (rvb)-[:KNOWS]->(ally)
    RETURN ee, js, ir, rvb, ally
    ```
    ![](images/neo4j_create_relations.png)
  - **MATCH relationships** 匹配关系
    ```js
    // 语法规则
    MATCH (匹配出的变量名 : 匹配的标签) -[:关系]-(匹配到的关系名)
    WHERE 过滤结果 RETURN 返回特定结果
    ```
    ```js
    // pattern can be used to find Emil's friends
    MATCH (ee:Person)-[:KNOWS]-(friends)
    WHERE ee.name = "Emil" RETURN ee, friends
    ```
    ![](images/neo4j_match_pattern_knows.png)
  - **Recommendations** 匹配关系进行推荐
    ```js
    // Recommd frind by "surfing"
    MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)
    WHERE js.name = "Johan" AND surfer.hobby = "surfing"
    RETURN DISTINCT surfer
    ```
    ![](images/neo4j_recommdation.png)
    - **() empty** 表示忽略这些匹配到的节点
    - **DISTINCT** because more than one path will match the pattern
  - **EXPLAIN / PROFILE** 显示匹配过程
    ```js
    PROFILE MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)
    WHERE js.name = "Johan" AND surfer.hobby = "surfing"
    RETURN DISTINCT surfer
    ```
    ![](images/neo4j_explain.png)
## MATCH CQL查询语句
  运行环境为在线浏览器-数据库是官方演员-电影图数据库

  1
  ```js
  MATCH (n) RETURN n // 查询所有节点
  MATCH (n)-->(m) RETURN n, m // 查询两个节点，一条边
  MATCH (n)-->( ) RETURN n // 也可缺失一个节点
  MATCH (person)-->() RETURN person.name // 返回节点的属性值：返回演员和导演的名字
  ```
  2查询关系-边
  ```js
  MATCH (person)-[rel]->(movie) RETURN person, type(rel) // 查询所有的边关系
  MATCH (actor)-[role:ACTED_IN]->(movie) RETURN actor.name, role.roles, movie.title // 查询哪个演员演了哪个电影：
  ```
  3 查询标签：
  ```js
  MATCH (actor:Person)-[:ACTED_IN]->(movie) RETURN actor.name, movie.title // 用标签查询 哪个演员表演过哪个电影
  MATCH (tom:Person) WHERE tom.name = "Tom Hanks" RETURN tom // 增加WHERE 条件筛选，名字叫Tom Hanks的演员
  MATCH (tom:Person {name:"Tom Hanks"}) RETURN tom // 还可以这样
  ```
  4 path：传递关系
  ```js
  // 查询哪个演员参演的电影，及这部电影的导演关系图
  MATCH (actor)-[:ACTED_IN]->(movie)<-[:DIRECTED]-(director)
  RETURN actor.name, movie.title, director.name;

  // 上面语句的另一种写法
  MATCH (actor)-[:ACTED_IN]->(movie),
        (movie)<-[:DIRECTED]-(director)
  RETURN actor.name, movie.title, director.name

  // 再来一种等价写法
  MATCH (actor)-[:ACTED_IN]->(movie),
        (director)-[:DIRECTED]->(movie)
  RETURN actor.name, movie.title, director.name;
  ```
  定义path
  ```js
  // 用p返回多有的path及其属性
  MATCH p=(a)-[:ACTED_IN]->(m)<-[:DIRECTED]-(d)
  RETURN p

  // 用节点node返回path
  MATCH p=(a)-[:ACTED_IN]->(m)<-[:DIRECTED]-(d)
  RETURN nodes(p)

  // 用关系rels返回path
  MATCH p=(a)-[:ACTED_IN]->(m)<-[:DIRECTED]-(d)
  RETURN rels(p)

  // 两个模式的path定义
  MATCH p1=(a)-[:ACTED_IN]->(m), p2=(d)-[:DIRECTED]->(m)
  RETURN p1, p2
  ```
***

# Movie Graph
## Create 创建
  - **Movie Graph** 演员-电影 图数据库，演员参演电影的关系图
    ```js
    :play movie-graph
    ```
  - [neo4j_movie_graph.cypher](neo4j_movie_graph.cypher)
    ```js
    // 示例
    CREATE (YouveGotMail:Movie {title:"You've Got Mail", released:1998, tagline:'At odds in life... in love on-line.'})
    CREATE (ParkerP:Person {name:'Parker Posey', born:1968})
    CREATE (DaveC:Person {name:'Dave Chappelle', born:1973})
    CREATE (SteveZ:Person {name:'Steve Zahn', born:1967})
    CREATE (TomH:Person {name:'Tom Hanks', born:1956})
    CREATE (NoraE:Person {name:'Nora Ephron', born:1941})
    CREATE
      (TomH)-[:ACTED_IN {roles:['Joe Fox']}]->(YouveGotMail),
      (MegR)-[:ACTED_IN {roles:['Kathleen Kelly']}]->(YouveGotMail),
      (GregK)-[:ACTED_IN {roles:['Frank Navasky']}]->(YouveGotMail),
      (ParkerP)-[:ACTED_IN {roles:['Patricia Eden']}]->(YouveGotMail),
      (DaveC)-[:ACTED_IN {roles:['Kevin Jackson']}]->(YouveGotMail),
      (SteveZ)-[:ACTED_IN {roles:['George Pappas']}]->(YouveGotMail),
      (NoraE)-[:DIRECTED]->(YouveGotMail)
    ```
  ![](images/neo4j_movie_create.png)
## Find 查找
  - 查找演员名 "Tom Hanks"
    ```js
    MATCH (tom {name: "Tom Hanks"}) RETURN tom
    ```
  - 查找电影名 "Cloud Atlas"
    ```js
    MATCH (cloudAtlas {title: "Cloud Atlas"}) RETURN cloudAtlas
    ```
  - 查找 10 个人
    ```js
    MATCH (people:Person) RETURN people.name LIMIT 10
    ```
  - 查找 90 年代的电影 `1990 <= released < 2000`
    ```js
    MATCH (nineties:Movie) WHERE nineties.released >= 1990 AND nineties.released < 2000 RETURN nineties.title
    ```
## Query 查询
  - 列出 "Tom Hanks" 的所有电影
    ```js
    MATCH (tom:Person {name: "Tom Hanks"})-[:ACTED_IN]->(tomHanksMovies) RETURN tom, tomHanksMovies
    ```
    ![](images/neo4j_movie_tom_hanks_movies.png)
  - "Cloud Atlas" 的导演
    ```js
    MATCH (cloudAtlas {title: "Cloud Atlas"})<-[:DIRECTED]-(directors) RETURN directors.name
    MATCH (cloudAtlas:Movie {title: "Cloud Atlas"})<-[:DIRECTED]-(director) RETURN director, cloudAtlas
    ```
    ![](images/neo4j_movie_ca_directors.png)
  - "Tom Hanks" 共同参演的演员
    ```js
    MATCH (tom:Person {name:"Tom Hanks"})-[:ACTED_IN]->(m)<-[:ACTED_IN]-(coActors) RETURN coActors.name
    MATCH (tom:Person {name: "Tom Hanks"})-[:ACTED_IN]->(m)<-[:ACTED_IN]-(coActors) RETURN tom, m, coActors
    ```
    ![](images/neo4j_movie_tom_hanks_coa.png)
  - 电影 "Cloud Atlas" 的人员关系
    ```js
    MATCH (people:Person)-[relatedTo]-(:Movie {title: "Cloud Atlas"}) RETURN people.name, Type(relatedTo), relatedTo
    MATCH (people:Person)-[relatedTo]-(ca:Movie {title: "Cloud Atlas"}) RETURN people, relatedTo, ca
    ```
    ![](images/neo4j_movie_ca_relation.png)
## Solve 最短路径 Bacon Path
  - 与 "Kevin Bacon" 4 层关系以内的演员喝电影
    ```js
    MATCH (bacon:Person {name:"Kevin Bacon"})-[*1..4]-(hollywood)
    RETURN DISTINCT hollywood

    MATCH (bacon:Person {name:"Kevin Bacon"})-[*1..2]-(hollywood)
    RETURN DISTINCT hollywood, bacon
    ```
    ![](images/neo4j_movie_becon_relation.png)
  - **Bacon path** "Kevin Bacon" 与 "Meg Ryan" 之间的最短路径
    ```js
    MATCH p=shortestPath(
      (bacon:Person {name:"Kevin Bacon"})-[*]-(meg:Person {name:"Meg Ryan"})
    )
    RETURN p
    ```
    ![](images/neo4j_movie_becon_path.png)
## Recommend 推荐
  - 为 "Tom Hanks" 推荐新的合作演员
    - 查找 Tom Hanks 合作过的演员，新的合作演员与这些演员合作过
    - Tom Hanks 没有与推荐的演员合作过
    ```js
    MATCH (tom:Person {name:"Tom Hanks"})-[:ACTED_IN]->(m)<-[:ACTED_IN]-(coActors),
          (coActors)-[:ACTED_IN]->(m2)<-[:ACTED_IN]-(cocoActors)
    WHERE NOT (tom)-[:ACTED_IN]->()<-[:ACTED_IN]-(cocoActors) AND tom <> cocoActors
    RETURN cocoActors.name AS Recommended, count(*) AS Strength ORDER BY Strength DESC
    ```
    | Recommended        | Strength |
    | ------------------ | -------- |
    | "Tom Cruise"       | 5        |
    | "Zach Grenier"     | 5        |
    | "Cuba Gooding Jr." | 4        |
    | "Carrie Fisher"    | 3        |
    | "Frank Langella"   | 2        |
    | "Ben Miles"        | 1        |
    | "Natalie Portman"  | 1        |
  - 查找能将 Tom Hanks 介绍给 Tom Cruise 的关系
    ```js
    MATCH (tom:Person {name:"Tom Hanks"})-[:ACTED_IN]->(m)<-[:ACTED_IN]-(coActors),
          (coActors)-[:ACTED_IN]->(m2)<-[:ACTED_IN]-(cruise:Person {name:"Tom Cruise"})
    RETURN tom, m, coActors, m2, cruise
    ```
    ![](images/neo4j_movie_recomm_tt.png)
## Clean up 删除电影数据
  - 关系存在的时候不能删除节点，必须同时删除节点与关系
  ```js
  // Delete all Movie and Person nodes, and their relationships
  MATCH (n) DETACH DELETE n
  // Prove that the Movie Graph is gone
  MATCH (n) RETURN n
  ```
***

# Northwind Graph
## Northwind 数据表结构
  - **RDBMS** 关系数据库管理系统 Relational Database Management System
  - **Northwind Graph** 将一个传统的关系型数据库转化为图数据库
    ```js
    :play northwind-graph
    ```
  - **Product Catalog** 产品类别，包含了 `产品 product - 类别 categories - 供应商 suppliers` 的数据

    ![](images/neo4j_nw_product_cata.png)
    - **products.csv**

      | productID | productName   | supplierID | categoryID | quantityPerUnit     | unitPrice | unitsInStock | unitsOnOrder | reorderLevel | discontinued |
      | --------- | ------------- | ---------- | ---------- | ------------------- | --------- | ------------ | ------------ | ------------ | ------------ |
      | 1         | Chai          | 1          | 1          | 10 boxes x 20 bags  | 18        | 39           | 0            | 10           | 0            |
      | 2         | Chang         | 1          | 1          | 24 - 12 oz bottles  | 19        | 17           | 40           | 25           | 0            |
      | 3         | Aniseed Syrup | 1          | 2          | 12 - 550 ml bottles | 10        | 13           | 70           | 25           | 0            |
    - **categories.csv**

      | categoryID | categoryName | description                                                | picture  |
      | ---------- | ------------ | ---------------------------------------------------------- | -------- |
      | 1          | Beverages    | Soft drinks, coffees, teas, beers, and ales                | 0x151... |
      | 2          | Condiments   | Sweet and savory sauces, relishes, spreads, and seasonings | 0x151... |
      | 3          | Confections  | Desserts, candies, and sweet breads                        | 0x151... |
    - **suppliers.csv**

      | supplierID | companyName                | contactName      | contactTitle         | address        | city        | region | postalCode | country | phone          | fax            | homePage    |
      | ---------- | -------------------------- | ---------------- | -------------------- | -------------- | ----------- | ------ | ---------- | ------- | -------------- | -------------- | ----------- |
      | 1          | Exotic Liquids             | Charlotte Cooper | Purchasing Manager   | 49 Gilbert St. | London      | NULL   | EC1 4SD    | UK      | (171) 555-2222 | NULL           | NULL        |
      | 2          | New Orleans Cajun Delights | Shelley Burke    | Order Administrator  | P.O. Box 78934 | New Orleans | LA     | 70117      | USA     | (100) 555-4822 | NULL           | #CAJUN.HTM# |
      | 3          | Grandma Kelly's Homestead  | Regina Murphy    | Sales Representative | 707 Oxford Rd. | Ann Arbor   | MI     | 48104      | USA     | (313) 555-5735 | (313) 555-3349 | NULL        |

  - **Customer Orders** 客户订单，包含了 `Custom - Order` 对应关系

    ![](images/neo4j_nw_customor_orders.png)
    - **customers.csv**

      | customerID | companyName                        | contactName    | ... |
      | ---------- | ---------------------------------- | -------------- | --- |
      | ALFKI      | Alfreds Futterkiste                | Maria Anders   | ... |
      | ANATR      | Ana Trujillo Emparedados y helados | Ana Trujillo   | ... |
      | ANTON      | Antonio Moreno Taquería            | Antonio Moreno | ... |
    - **orders.csv**

      | orderID | customerID | employeeID | orderDate               | ... |
      | ------- | ---------- | ---------- | ----------------------- | --- |
      | 10248   | VINET      | 5          | 1996-07-04 00:00:00.000 | ... |
      | 10249   | TOMSP      | 6          | 1996-07-05 00:00:00.000 | ... |
      | 10250   | HANAR      | 4          | 1996-07-08 00:00:00.000 | ... |
  - **OrderDetail** 包含了 `Order - Product` 的对应关系

    | orderID | productID | unitPrice | quantity | discount |
    | ------- | --------- | --------- | -------- | -------- |
    | 10248   | 11        | 14        | 12       | 0        |
    | 10248   | 42        | 9.8       | 10       | 0        |
    | 10248   | 72        | 34.8      | 5        | 0        |
## 加载 Product Catalog CSV 文件
  - **LOAD CSV**
    ```js
    :help cypher LOAD CSV
    ```
  - **加载 products.csv / categories.csv / suppliers.csv 文件**
    ```js
    // products.csv
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/products.csv" AS row
    CREATE (n:Product)
    SET n = row,
      n.unitPrice = toFloat(row.unitPrice),
      n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder),
      n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued <> "0")
    ```
    ```js
    // categories.csv
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/categories.csv" AS row
    CREATE (n:Category)
    SET n = row
    ```
    ```js
    // suppliers.csv
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/suppliers.csv" AS row
    CREATE (n:Supplier)
    SET n = row
    ```
  - **Create indexes** 创建索引
    ```js
    CREATE INDEX ON :Product(productID)
    ```
    ```js
    CREATE INDEX ON :Category(categoryID)
    ```
    ```js
    CREATE INDEX ON :Supplier(supplierID)
    ```
## 创建 Product Catalog 关系图
  - products / categories / suppliers 通过 **ID 键值** 联系起来

    ![](images/neo4j_nw_product_cata_relation.png)
  - **创建关系 relationships**
    ```js
    :help cypher MATCH
    ```
    ```js
    MATCH (p:Product),(c:Category)
    WHERE p.categoryID = c.categoryID
    CREATE (p)-[:PART_OF]->(c)
    ```
    ```js
    MATCH (p:Product),(s:Supplier)
    WHERE p.supplierID = s.supplierID
    CREATE (s)-[:SUPPLIES]->(p)
    ```
  - 查找每个供应商 supplier 提供的产品类别 categories
    ```js
    MATCH (s:Supplier)-->(:Product)-->(c:Category)
    RETURN s.companyName as Company, collect(distinct c.categoryName) as Categories
    ```
    | Company         | Categories                                    |
    | --------------- | --------------------------------------------- |
    | "Lyngbysild"    | ["Seafood"]                                   |
    | "G'day"         | ["Grains/Cereals", "Meat/Poultry", "Produce"] |
    | "Tokyo Traders" | ["Meat/Poultry", "Produce", "Seafood"]        |

  - 查找 "Produce" 类别的供应商
    ```js
    MATCH (c:Category {categoryName:"Produce"})<--(p:Product)<--(s:Supplier)
    RETURN DISTINCT s.companyName as ProduceSuppliers
    RETURN s, p, c
    ```
    ![](images/neo4j_nw_produce_relation.png)
## 加载 Customer Orders CSV 文件
  - 加载 **customers.csv** / **orders.csv** 文件
    ```js
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/customers.csv" AS row
    CREATE (n:Customer)
    SET n = row
    ```
    ```js
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/orders.csv" AS row
    CREATE (n:Order)
    SET n = row
    ```
  - **Create indexes** 创建索引
    ```js
    CREATE INDEX ON :Customer(customerID)

    CREATE INDEX ON :Order(orderID)
    ```
## 创建 Customer Orders 关系图
  ![](images/neo4j_nw_customoe_order_relation.png)
  ```js
  MATCH (c:Customer),(o:Order)
  WHERE c.customerID = o.customerID
  CREATE (c)-[:PURCHASED]->(o)
  ```
## Order Detail CSV 文件
  - 加载 **order-details.csv** 文件，并将 **Product** 与 **Order** 关联起来
    ```js
    LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/order-details.csv" AS row
    MATCH (p:Product), (o:Order)
    WHERE p.productID = row.productID AND o.orderID = row.orderID
    CREATE (o)-[details:ORDERS]->(p)
    SET details = row,
      details.quantity = toInteger(row.quantity)
    ```
  - 综合查询
    ```js
    MATCH (cust:Customer)-[:PURCHASED]->(:Order)-[o:ORDERS]->(p:Product),
          (p)-[:PART_OF]->(c:Category {categoryName:"Produce"})
    RETURN DISTINCT cust.contactName as CustomerName, SUM(o.quantity) AS TotalProductsPurchased
    ```
***

# Neo4j CQL 命令格式
## Neo4j CQL 简介
  - CQL代表Cypher查询语言，遵循SQL语法
  - **常用的 Neo4j CQL 命令**
    | CQL 命令    | 用法                         |
    | ----------- | ---------------------------- |
    | CREATE 创建 | 创建节点，关系和属性         |
    | MATCH 匹配  | 检索有关节点，关系和属性数据 |
    | RETURN 返回 | 返回查询结果                 |
    | WHERE 过滤  | 提供条件过滤检索数据         |
    | DELETE 删除 | 删除节点和关系               |
    | REMOVE 移除 | 删除节点和关系的属性         |
    | ORDER BY    | 以…排序 排序检索数据         |
    | SET 设置    | 添加或更新标签               |

  - **常用的 Neo4j CQL 函数**
    | 定制列表功能      | 用法                                           |
    | ----------------- | ---------------------------------------------- |
    | String 字符串     | 用于使用 String 字面量                       |
    | Aggregation 聚合  | 用于对 CQL 查询结果执行一些聚合操作          |
    | Relationship 关系 | 用于获取关系的细节，如 startnode，endnode 等 |

  - **Neo4j CQL 数据类型**
    | CQL数据类型 | 用法                  |
    | ----------- | --------------------- |
    | boolean     | 布尔文字：true，false |
    | byte        | 8位整数               |
    | short       | 16位整数              |
    | int         | 32位整数              |
    | long        | 64位整数              |
    | float       | 32位浮点数            |
    | double      | 64位浮点数            |
    | char        | 16位字符              |
    | String      | 字符串                |
## CREATE
  - 创建 节点 / 关系 / 标签
    ```js
    // 创建没有属性的节点
    CREATE (<node-name>:<label-name>)

    // 创建多个标签的节点
    CREATE (<node-name>:<label-name1>:<label-name2>.....:<label-namen>)

    // 创建具有属性的节点
    CREATE (
       <node-name>:<label-name>
       { 	
          <Property1-name>:<Property1-Value>
          ........
          <Propertyn-name>:<Propertyn-Value>
       }
    )

    // 创建节点间的关系
    CREATE (<node1-name>:<label1-name>)-
    	[(<relationship-name>:<relationship-label-name>)]
    	->(<node2-name>:<label2-name>)
    ```
  - **node-name** 节点名，不能用来访问节点详细信息
  - **label-name** 标签名，可以用来访问节点详细信息
## MATCH
  - 从数据库获取有关节点，关系和属性的数据
    ```js
    MATCH ( <node-name>:<label-name> )

    // MATCH WHERE RETURN / DELETE / CREATE / ...
    MATCH (<node-name>:<label-name>) WHERE <condition> RETURN <node-name>.<property1-name>
    ```
  - 不能单独使用 MATCH 从数据库检索数据，配合使用 RETURN 子句 / DELETE 子句 等
## RETURN
  - 返回 节点 / 关系的 某些 / 全部 属性
    ```js
    RETURN <node-name>.<property1-name>, <node-name>.<propertyn-name>

    RETURN <node-name>.<property1-name> AS <name1>, <node-name>.<propertyn-name> AS <name2>
    ```
  - 配合 MATCH 使用
  - 可以配合使用 ORDER BY / AS / LIMIT / SKIP 等子句
## WHERE
  - WHERE子句来过滤MATCH查询的结果
    ```js
    // 单一条件
    WHERE <property-name> <comparison-operator> <value>

    // 布尔运算符
    WHERE <condition> <boolean-operator> <condition>

    // MATCH WHERE CREATE，创建两个现有节点之间的关系
    MATCH (<node1-label-name>:<node1-name>),(<node2-label-name>:<node2-name>)
    WHERE <condition>
    CREATE (<node1-label-name>)-[<relationship-label-name>:<relationship-name>
           {<relationship-properties>}]->(<node2-label-name>)
    ```
  - **boolean-operator 布尔运算符**
    | 布尔运算符 | 描述 |
    | ---------- | ---- |
    | AND        | 与   |
    | OR         | 或   |
    | NOT        | 非   |
    | XOR        | 异或 |

  - **comparison-operator 比较运算符**
    | 布尔运算符 | 描述       |
    | ---------- | ---------- |
    | =          | 等于       |
    | <>         | 不等于     |
    | <          | 小于       |
    | >          | 大于       |
    | <=         | 小于或等于 |
    | >=         | 大于或等于 |
## DELETE
  - 用于删除节点和关联关系
    ```js
    DELETE <node-name-list>
    DELETE <node1-name>,<node2-name>,<relationship-name>
    ```
## REMOVE
  - 用于删除标签和属性
    ```js
    // 删除节点/关系的属性
    REMOVE <node-name>.<property1-name>, <node-name>.<property2-name>

    // 删除节点/关系的标签
    REMOVE <node-name>:<label1-name>, <node-name>:<label2-name>
    ```
## SET
  - 向现有 节点 / 关系 添加 / 更新 属性值
    ```js
    SET  <node-label-name>.<property1-name>, <node-label-name>.<property2-name>
    ```
## ORDER BY
  - 对 MATC H查询返回的结果进行排序
    ```js
    // 默认按升序对行进行排序，DESC 指定降序排列
    ORDER BY  <node-label-name>.<property1-name>, <node-label-name>.<property2-name> [DESC]
    ```
## UNION
  - **UNION** 将两组结果中的公共行组合并返回到一组结果中，不返回重复行
    ```js
    <MATCH Command1>
      UNION
    <MATCH Command2>
    ```
  - **UNION ALL** 将两组结果中的公共行组合并返回到一组结果中，返回重复行
    ```js
    <MATCH Command1>
      UNION ALL
    <MATCH Command2>
    ```
  - **限制** 组合的两个结果集的名字必须匹配，**列名称** 与 **列的数据类型** 应该是相同的
  - 可使用 **AS** 统一返回的列名称
## AS
  - 用于给一些列起别名，如 RETURN 的返回结果，或用于 UNION 时统一列名
    ```js
    MATCH (<node1-name>:<label1-name>)
    RETURN <node1-name>.<property1-name> AS <name1>,
        <node1-name>.<propertyn-name> AS <name2>
    UNION
    MATCH (<node2-name>:<label2-name>)
    RETURN <node2-name>.<property2-name> AS <name1>,
        <node2-name>.<propertyn-name> AS <name2>
    ```
## LIMIT
  - 过滤或限制查询返回的行数，取 **顶部** 的 number 行
    ```js
    LIMIT <number>
    ```
## SKIP
  - 过滤或限制查询返回的行数，取 **底部** 的 number 行
    ```js
    SKIP <number>
    ```
## MERGE
  - **MERGE** 命令是 CREATE 命令和 MATCH 命令的组合
    - 搜索给定模式，如果存在，则返回结果
    - 如果不存在，则创建新的节点 / 关系并返回结果
    ```js
    MERGE (<node-name>:<label-name>
    {
       <Property1-name>:<Pro<rty1-Value>
       .....
       <Propertyn-name>:<Propertyn-Value>
    })
    ```
## NULL 值
  - **NULL** 空值，节点 / 关系的属性的 **缺失值** 或 **未定义值**
    ```js
    // 过滤 NULL 行
    WHERE IS NULL
    WHERE IS NOT NULL
    ```
## IN
  - 用于提供一组值的集合
    ```js
    IN [<Collection-of-values>]

    // MATCH WHERE IN RETURN
    MATCH (<node-name>:<label-name>)
    WHERE <node-name>.<property-name> IN [<value1>, <value2>, <value3>]
    RETURN <node-name>.<property1-name>, <node-name>.<property2-name>
    ```
## ID 属性
  - **Id** 是节点和关系的默认内部属性，当创建一个新的节点或关系时，Neo4j 数据库服务器将为内部使用分配一个数字，自动递增
## INDEX 索引
  - 为具有 **相同标签名称** 的所有 节点 / 关系 的属性创建索引，以提高应用程序的性能
  - **创建索引 CREATE INDEX ON**
    ```js
    // 在节点或关系的 <label_name> 的 <property_name> 上创建一个新索引
    CREATE INDEX ON :<label_name> (<property_name>)
    ```
  - **删除索引 DROP INDEX ON**
    ```js
    // 删除在节点或关系的 <label_name> 的 <property_name> 上创建的现有索引
    DROP INDEX ON :<label_name> (<property_name>)
    ```
## UNIQUE 约束
  - CREATE 命令始终创建新的节点或关系，即使使用相同的值，也会插入一个新行
  - **UNIQUE 约束** 避免重复记录，强制执行数据完整性规则
  - **创建 UNIQUE 约束 CREATE CONSTRAINT ON**
    ```js
    CREATE CONSTRAINT ON (<label_name>)
    ASSERT <property_name> IS UNIQUE
    ```
  - **删除 UNIQUE 约束 DROP CONSTRAINT ON**
    ```js
    DROP CONSTRAINT ON (<label_name>)
    ASSERT <property_name> IS UNIQUE
    ```
***

# Neo4J CQL 函数
## String 字符串函数
  - **字符串函数列表**
    | 功能      | 描述                     | 语法                                               |
    | --------- | ------------------------ | -------------------------------------------------- |
    | UPPER     | 所有字母更改为大写字母   | UPPER(<input-string>)                             |
    | LOWER     | 所有字母改为小写字母     | LOWER(<input-string>)                             |
    | SUBSTRING | 获取给定String的子字符串 | SUBSTRING(<input-string>,<startIndex> ,<endIndex>) |
    | REPLACE   | 替换一个字符串的子字符串 |                                                    |
## Aggregation 聚合函数
  - **聚合函数列表**，类似于SQL中的GROUP BY子句
    | 聚集功能 | 描述                              | 语法                 |
    | -------- | --------------------------------- | -------------------- |
    | COUNT    | 统计由 MATCH 命令返回的行数       | COUNT(<value>)       |
    | MAX      | 返回一组属性中的最大值            | MAX(<property-name>) |
    | MIN      | 返回一组属性中的最大值            | MIN(<property-name>) |
    | SUM      | 返回 MATCH 结果中某一属性的和     | AVG(<property-name>) |
    | AVG      | 返回 MATCH 结果中某一属性的平均值 | SUM(<property-name>) |
## Relationship 关系函数
  - **关系函数列表**，获取 开始节点 / 结束节点等关系的细节
    | 功能      | 描述           | 语法                                 |
    | --------- | -------------- | ------------------------------------ |
    | STARTNODE | 关系的开始节点 | STARTNODE(<relationship-label-name>) |
    | ENDNODE   | 关系的结束节点 | ENDNODE(<relationship-label-name>)   |
    | ID        | 关系的 ID      | ID(<relationship-label-name>)        |
    | TYPE      | 关系的 TYPE    | TYPE(<relationship-label-name>)      |
***

# py2neo
- [The Py2neo v4 Handbook](https://py2neo.org/v4/)
- [py2neo github](https://github.com/technige/py2neo)
## Node Relation Property
  - Neo4j 里面最重要的两个数据结构就是 **节点 Node** 和 **关系 Relationship**，可以通过 Node 或 Relationship 对象创建
    ```python
    from py2neo import Node, Relationship

    a = Node('Person', name='Alice')
    b = Node('Person', name='Bob')
    r = Relationship(a, 'KNOWS', b)
    print(a, b, r)
    # (:Person {name: 'Alice'}) (:Person {name: 'Bob'}) (Alice)-[:KNOWS {}]->(Bob)
    ```
  - Node 和 Relationship 都继承了 **PropertyDict** 类，它可以赋值很多属性，类似于字典的形式
    ```python
    a['age'] = 20
    b['age'] = 21
    r['time'] = '2017/08/31'
    print(a, b, r)
    # (:Person {age: 20, name: 'Alice'}) (:Person {age: 21, name: 'Bob'}) (Alice)-[:KNOWS {time: '2017/08/31'}]->(Bob)
    ```
  - **setdefault** 方法赋值默认属性
    ```python
    a.setdefault('location', 'Bei Jing')
    print(a)
    # (:Person {age: 20, location: 'Bei Jing', name: 'Alice'})
    ```
    赋值 location 属性，覆盖默认属性
    ```python
    a['location'] = 'Shang Hai'
    a.setdefault('location', 'Bei Jing')
    print(a)
    # (:Person {age: 20, location: 'Shang Hai', name: 'Alice'})
    ```
  - **update** 方法对属性批量更新
    ```python
    data = {
        'name': 'Amy',
        'age': 21
    }
    a.update(data)
    print(a)
    # (:Person {age: 21, location: 'Shang Hai', name: 'Amy'})
    ```
## Subgraph 子图
- **Subgraph 子图** 是 Node 和 Relationship 的集合，最简单的构造子图的方式是通过关系运算符
  ```python
  from py2neo import Node, Relationship

  a = Node('Person', name='Alice')
  b = Node('Person', name='Bob')
  r = Relationship(a, 'KNOWS', b)
  s = a | b | r

  print(list(s.nodes))
  # [(:Person {name: 'Alice'}), (:Person {name: 'Bob'})]
  print(list(s.relationships))
  # [(Alice)-[:KNOWS {}]->(Bob)]
  ```
- **&** 取 Subgraph 的交集
  ```python
  s1 = a | b | r
  s2 = a | b
  ss = s1 & s2

  print(list(ss.nodes))
  # [(:Person {name: 'Alice'}), (:Person {name: 'Bob'})]
  print(list(ss.relationships))
  # []
  ```
- **labels / nodes / relationships / keys() / types()** 分别获取 Subgraph 的属性值
  ```python
  s = a | b | r
  print(s.keys())
  # frozenset({'name'})
  print(list(s.labels))
  # ['Person']
  print(list(s.nodes))
  # [(:Person {name: 'Alice'}), (:Person {name: 'Bob'})]
  print(list(s.relationships))
  # [(Alice)-[:KNOWS {}]->(Bob)]
  print(s.types())
  # frozenset({'KNOWS'})
  ```
## Walkable
  - **Walkable** 增加了遍历信息的 Subgraph，通过 **+** 构建一个 Walkable 对象
    ```python
    from py2neo import Node, Relationship

    a = Node('Person', name='Alice')
    b = Node('Person', name='Bob')
    c = Node('Person', name='Mike')
    ab = Relationship(a, "KNOWS", b)
    ac = Relationship(a, "KNOWS", c)
    w = ab + Relationship(b, "LIKES", c) + ac

    print(type(w))
    # <class 'py2neo.data.Walkable'>
    print(w.nodes)
    # ((:Person {name: 'Alice'}), (:Person {name: 'Bob'}), (:Person {name: 'Mike'}), (:Person {name: 'Alice'}))
    print(w.relationships)
    # ((Alice)-[:KNOWS {}]->(Bob), (Bob)-[:LIKES {}]->(Mike), (Alice)-[:KNOWS {}]->(Mike))
    ```
  - **walk** 方法实现遍历
    ```python
    from py2neo import walk

    for item in walk(w):
        print(item)

    # (:Person {name: 'Alice'})
    # (Alice)-[:KNOWS {}]->(Bob)
    # (:Person {name: 'Bob'})
    # (Bob)-[:LIKES {}]->(Mike)
    # (:Person {name: 'Mike'})
    # (Alice)-[:KNOWS {}]->(Mike)
    # (:Person {name: 'Alice'})
    ```
  - **start_node / end_node / nodes / relationships** 获取 Walkable 的属性值
    ```python
    print(w.start_node)
    # (:Person {name: 'Alice'})
    print(w.end_node)
    # (:Person {name: 'Alice'})
    print(w.nodes)
    # ((:Person {name: 'Alice'}), (:Person {name: 'Bob'}), (:Person {name: 'Mike'}), (:Person {name: 'Alice'}))
    print(w.relationships)
    # ((Alice)-[:KNOWS {}]->(Bob), (Bob)-[:LIKES {}]->(Mike), (Alice)-[:KNOWS {}]->(Mike))
    ```
    - start_node 与 end_node 是同一个
## Graph
- **Graph** 代表了 Neo4j 的图数据库，提供了许多方法来操作 Neo4j 数据库
- **初始化**，默认的连接是  `bolt://localhost：7687` `neo4j / password`
  ```python
  from py2neo import Graph
  graph_1 = Graph("http://localhost:7474")
  graph_2 = Graph(scheme='http', host="localhost", port=7474)

  graph_3 = Graph("http://localhost:7474", auth=('neo4j', 'neo4j'))
  graph_4 = Graph("http://localhost:7474", password='neo4j', user='neo4j')
  ```
  | Keyword    | Description                            | Type  | Default                 |
  | ---------- | -------------------------------------- | ----- | ----------------------- |
  | auth       | A 2-tuple of (user, password)          | tuple | ('neo4j', 'password')   |
  | host       | Database server host name              | str   | 'localhost'             |
  | password   | Password to use for authentication     | str   | 'password'              |
  | port       | Database server port                   | int   | 7687                    |
  | scheme     | Use a specific URI scheme              | str   | 'bolt'                  |
  | secure     | Use a secure connection (TLS)          | bool  | False                   |
  | user       | User to authenticate as                | str   | 'neo4j'                 |
  | user_agent | User agent to send for all connections | str   | (depends on URI scheme) |
- **create** 方法传入 Subgraph 对象来将关系图添加到数据库中
  ```python
  from py2neo import Node, Relationship, Graph

  a = Node('Person', name='Alice')
  b = Node('Person', name='Bob')
  r = Relationship(a, 'KNOWS', b)
  s = a | b | r
  graph = Graph("http://localhost:7474", auth=('neo4j', 'neo4j'))
  graph.create(s)

  from py2neo import Graph, Node, Relationship
  g = Graph("http://localhost:7474", auth=('neo4j', 'neo4j'))
  tx = g.begin()
  a = Node("Person", name="Alice")
  tx.create(a)
  b = Node("Person", name="Bob")
  ab = Relationship(a, "KNOWS", b)
  tx.create(ab)
  tx.commit()
  g.exists(ab)
  ```
另外还可以利用 data() 方法来获取查询结果：

from py2neo import Graph

graph = Graph(password='123456')
data = graph.data('MATCH (p:Person) return p')
print(data)

这里是通过 CQL 语句实现的查询，输出结果即 CQL 语句的返回结果，是列表形式。

另外输出结果还可以直接转化为 DataFrame 对象，实例如下：

from py2neo import Graph
from pandas import DataFrame
graph = Graph(password='123456')
data = graph.data('MATCH (p:Person) return p')
df = DataFrame(data)
print(df)

另外可以使用 find_one() 或 find() 方法进行 Node 的查找，可以利用 match() 或 match_one() 方法对 Relationship 进行查找：

from py2neo import Graph

graph = Graph(password='123456')
node = graph.find_one(label='Person')
print(node)
relationship = graph.match_one(rel_type='KNOWS')
print(relationship)

如果想要更新 Node 的某个属性可以使用 push() 方法，例如：

from py2neo import Graph, Node

graph = Graph(password='123456')
a = Node('Person', name='Alice')
node = graph.find_one(label='Person')
node['age'] = 21
graph.push(node)
print(graph.find_one(label='Person'))

如果想要删除某个 Node 可以使用 delete() 方法，例如：

from py2neo import Graph

graph = Graph(password='123456')
node = graph.find_one(label='Person')
relationship = graph.match_one(rel_type='KNOWS')
graph.delete(relationship)
graph.delete(node)

在删除 Node 时必须先删除其对应的 Relationship，否则无法删除 Node。

另外我们也可以通过 run() 方法直接执行 CQL 语句，例如：

from py2neo import Graph

graph = Graph(password='123456')
data = graph.run('MATCH (p:Person) RETURN p LIMIT 5')
print(list(data))

## NodeSelector

Graph 有时候用起来不太方便，比如如果要根据多个条件进行 Node 的查询是做不到的，在这里更方便的查询方法是利用 NodeSelector，我们首先新建如下的 Node 和 Relationship，实例如下：

from py2neo import Graph, Node, Relationship

graph = Graph(password='123456')
a = Node('Person', name='Alice', age=21, location='广州')
b = Node('Person', name='Bob', age=22, location='上海')
c = Node('Person', name='Mike', age=21, location='北京')
r1 = Relationship(a, 'KNOWS', b)
r2 = Relationship(b, 'KNOWS', c)
graph.create(a)
graph.create(r1)
graph.create(r2)

运行结果：

在这里我们用 NodeSelector 来筛选 age 为 21 的 Person Node，实例如下：

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person', age=21)
print(list(persons))
1
2
3
4
5
6

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person', age=21)
print(list(persons))

运行结果：

[(d195b2e:Person {age:21,location:"广州",name:"Alice"}), (eefe475:Person {age:21,location:"北京",name:"Mike"})]
1

[(d195b2e:Person {age:21,location:"广州",name:"Alice"}), (eefe475:Person {age:21,location:"北京",name:"Mike"})]

另外也可以使用 where() 进行更复杂的查询，例如查找 name 是 A 开头的 Person Node，实例如下：

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person').where('_.name =~ "A.*"')
print(list(persons))
1
2
3
4
5
6

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person').where('_.name =~ "A.*"')
print(list(persons))

运行结果：

[(bcd8072:Person {age:21,location:"广州",name:"Alice"})]
1

[(bcd8072:Person {age:21,location:"广州",name:"Alice"})]

在这里用了正则表达式匹配查询。

另外也可以使用 order_by() 进行排序：

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person').order_by('_.age')
print(list(persons))
1
2
3
4
5
6

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
persons = selector.select('Person').order_by('_.age')
print(list(persons))

运行结果：

[(e3fc3d7:Person {age:21,location:"广州",name:"Alice"}), (da0179d:Person {age:21,location:"北京",name:"Mike"}), (cafa16e:Person {age:22,location:"上海",name:"Bob"})]
1

[(e3fc3d7:Person {age:21,location:"广州",name:"Alice"}), (da0179d:Person {age:21,location:"北京",name:"Mike"}), (cafa16e:Person {age:22,location:"上海",name:"Bob"})]

前面返回的都是列表，如果要查询单个节点的话，可以使用 first() 方法，实例如下：

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
person = selector.select('Person').where('_.name =~ "A.*"').first()
print(person)
1
2
3
4
5
6

from py2neo import Graph, NodeSelector

graph = Graph(password='123456')
selector = NodeSelector(graph)
person = selector.select('Person').where('_.name =~ "A.*"').first()
print(person)

运行结果：

(ea81c04:Person {age:21,location:"广州",name:"Alice"})
1

(ea81c04:Person {age:21,location:"广州",name:"Alice"})

更详细的内容可以查看：http://py2neo.org/v3/database.html#cypher-utilities。

# 结合项目浅谈Neo4j里值得注意的地方

写这篇blog主要也是因为最近再做一个关系查找的数据库，在使用Neo4j的时候还是自己挖了不少坑愉快的跳了下去然后到处挣扎。不过大部分的情况下终归还是能爬出来，在这里把遇到的一些问题和值得注意的地方分享出来，希望别人不要走我的老路。
关于节点和关系的建立

    建立节点和关系之前最好先查找一下是否已经存在这个节点了。如果已经存在的话，则建立关系的时候使用自己查找到的这个节点，而不要新建，否则会出现一个新的节点。

    如果一条条建立关系和节点的话，速度并不快。如果条件合适的话，最好还是用Neo4j的批量导入功能。不过因为在本项目里面并不适合使用批量导入功能，所以只能一条条的插入。

关于索引

    在Neo4j 2.0版本以后，尽量使用schema index，而不要使用旧版本的索引。

    最好在插入数据之前就建立好索引，否则索引的建立会很消耗时间。

    索引建立是非常有必要的，一个索引可以很大程度上降低大规模数据的查询速度。

    以我自己为例，这次做项目的时候因为第一次没有加入索引，当数据规模达到4w节点，7w+关系的时候，查询一个节点以及相关联的节点关系所消耗的时间已经达到了1s。

    在对节点按照name属性建立了索引之后，截止我写这篇blog的时候，数据量为节点600w+,关系1100w+，查询一个节点以及相关联的节点关系消耗的时间和数据量很小的时候几乎没有什么差别，基本上都稳定在16~20ms左右。

关于Neo4j应当插入的数据内容

    我们在使用图数据库的时候必须要明确一点，图数据库能够帮助我们的是以尽量快的速度找出来不同的节点之间的关系。因此向一个节点或者关系里面插入很多其余无关的数据是完全没有必要的，会很大程度浪费硬盘资源，在检索的时候也会消耗更多的时间。

    仍旧是以我这次的项目为例。截止到写这篇blog时已经向里面导入了2w条原始数据，我导入的每条数据中，有大量的跟关联关系无关的其他数据，但是这些都是没有必要的冗余数据，完全不需要向Neo4j里面插入。

    在最后我设计的图数据库里，节点类型为Person，每个节点只有一个属性name，标志这个节点。每两个节点之间最多只会有一来一回两条关系，表示主从关系。

    通过这样的图，我们想要检索任何节点的关联节点都可以很快速的找到，而且可以很清楚的区分哪些节点的联系比较紧密。

    如果要把其他的不必要的数据插入进去，跟2w条原始数据对应的600w+的节点和1100w+的关系，必然会占用大量的存储空间，也会大幅增加查询的时间。

    所以务必牢记，图数据库的本质是为了方便查找不同的人或者事物之间的关系的，而不是为了存储数据的。
